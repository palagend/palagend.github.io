<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>general on 困惑的人生</title>
    <link>https://palagend.github.io/categories/general/</link>
    <description>Recent content in general on 困惑的人生</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Wed, 06 Nov 2019 19:25:28 +0800</lastBuildDate>
    
	<atom:link href="https://palagend.github.io/categories/general/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>李健与孟小蓓的爱情就像信天翁</title>
      <link>https://palagend.github.io/posts/2019/11/%E6%9D%8E%E5%81%A5%E4%B8%8E%E5%AD%9F%E5%B0%8F%E8%93%93%E7%9A%84%E7%88%B1%E6%83%85%E5%B0%B1%E5%83%8F%E4%BF%A1%E5%A4%A9%E7%BF%81/</link>
      <pubDate>Wed, 06 Nov 2019 19:25:28 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2019/11/%E6%9D%8E%E5%81%A5%E4%B8%8E%E5%AD%9F%E5%B0%8F%E8%93%93%E7%9A%84%E7%88%B1%E6%83%85%E5%B0%B1%E5%83%8F%E4%BF%A1%E5%A4%A9%E7%BF%81/</guid>
      <description>如果说歌手中一定有一个另类，那一定是李健。
世人皆匆忙，总有几个人不想赶路。
就如同高晓松说的一般：“我们身边的这一波人都不是当初的模样了，只有李健还是当年那个李健。”
然而最重要的是他对妻子的痴情与专一，打动了无数人。
参加《我是歌手》后，
李健成了无数人心中的偶像，尤其是众多女性眼里的“万人迷”。
有个记者曾经问他：“你知道么，很多女人都爱你。”
而当时李健是这么回答的：
 “我对女人充满了关爱和尊敬，
但我不会跟女性走得太近，
也不可能离婚。
我也喜欢很多女孩子，
但远远欣赏就够了。
我们可以欣赏很多人，
但不一定要去占有她。”
 李健出道这么多年，也一直保持着零绯闻的记录。
活成众人男神的他，从始至终，只钟情于一人，就是那个她10岁时遇见的姑娘——孟小蓓。
曾经有记者问李健，你们在哪里度的蜜月？
李健回答：“我一生都在度蜜月”。
我们羡慕“从前慢，车、马、邮件都慢，一生只爱一个人”的时光时，李健是那个真正溯流而上，去实现它的人。
李健在自己10岁时就与自己的妻子孟小蓓认识了。
“郎骑竹马来，绕床弄青梅”，后来那首被王菲一唱而红的《传奇》，就是李健写来形容他跟妻子奇妙的际遇。
&amp;ldquo;只因为在人群中多看了你一眼，再也没能忘掉你容颜&amp;rdquo;
那一年他十岁，她五岁。
无论贫贵富贱，小贝壳都默默的陪在李建身边不离不弃。
不管是广电总局上班的三年，还是后来在“水木年华”大红大紫的几年，亦或是李健隐退在四合院清贫写歌的那几年。
两人从来没有出现过裂痕，平淡却很知足。
小贝壳也成为了李健的精神之柱。
或许所谓的灵魂伴侣就是这般模样吧。
之后，李健为她写了很多情歌，《小鸟睡在我身旁》、《一往情深的恋人》、《转眼瞬间》以及《恋人》。
几乎每张专辑都有一首曲子与小贝壳有关。
《恋人》：
“写这首歌的时候，已经是后半夜了，用尽所有的情感专注于它，我的小贝壳被感动的一塌糊涂，可不知为什么脑海里总浮现天鹅的形象。后来才听说，一对天鹅中如果有一只死去，另一只也会随之而去。”
《小鸟睡在我身旁》：
“有一天夜里，我看着窗外树上的鸟窝，想里面的小鸟一定睡得很香甜，我身旁的小贝壳也静静地睡着，就像一只小鸟&amp;hellip; &amp;hellip; ”
《在每个想你的夜里》：
“写这首歌是在芝加哥，每每听到都会想起那里的冬天，至少能感觉当时空气中的味道。”
《转眼瞬间》：
“我不太在意变老，因为见过活得精彩的老人，可我在乎眼中的你，看到你变老，我会伤感&amp;hellip;”
《凌晨两点》：
“这是脆弱的时刻，看着窗外的大雾，弹起吉他：我的生活不能没有你……”
他一生的情歌，都只为她而唱。
网上曾有个很流行的问题：“怎样才能嫁给李健？”
有一个很火的答案这样说：
 你要会泡茶，养花，煮咖啡，懂摄影，要会弹琴画画还要厨艺好，要会翻译叶芝的诗，会做牛排番茄面、地中海沙拉。要知道玻璃蜥蜴不是蛇，要知道怎么做出清香晶莹最好吃的白米粽，还要成为清华的博士，在路上被星探搭讪。最重要的是，你还要在5岁的时候遇见他。”
 这段看似“你在逗我吗？”的段子般的条件，却真实的体现在了两人的婚姻关系中。其实就是李
他们真正做到了把婚姻活成了诗情画意。
李健会用“小贝壳”来称呼妻子，妻子会用各种“先生”来指代他，所有的“柴米油盐酱醋茶”都雅成了“ 琴棋书画诗酒茶”。
李健说， “她是天上掉下来的”。
“太太最终吸引我的不是容貌，是她说话的方式和内容。”
翻看小贝壳的微博，会发现，两个人这么多年，如诗一般的始终甜蜜如初。</description>
    </item>
    
    <item>
      <title>PasteDeploy</title>
      <link>https://palagend.github.io/posts/2019/10/pastedeploy/</link>
      <pubDate>Thu, 03 Oct 2019 16:13:20 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2019/10/pastedeploy/</guid>
      <description>PasteDeploy 简介 PasteDeploy 是用来发现和配置 WSGI 应用的一个框架，可以方便地从配置文件加载 WSGI 应用。
PasteDeploy 的安装命令是 pip install PasteDeploy
PasteDeploy 配置文件 使用 PasteDeploy 都是围绕配置文件展开的，所以了解 PasteDeploy 配置的格式是熟练使用 PasteDeploy 的前提。
PasteDeploy 的配置文件由若干 section 组成，section 的组成格式如下：
[type:name]  其中方括号括起来的部分是声明 setion 的起始部分，section 的类型（type）和 section 的名称（name），如：[app:main] 等。section 的 type 可以有：app、composite、filter、pipeline、filter-app 等。
每个 section 中具体配置项的格式就是基本的 ini 格式：key = value，此外，PasteDeploy 的配置文件中使用 “#” 标注注释。
在基本了解 PasteDeploy 配置文件的书写格式后，我们不妨看一个实例，来具体了解不同 type 的 section。
PasteDeploy 中 section 的 type 示例 1：PasteDeploy 配置文件
[composite:main] use = egg:Paste#urlmap / = home /blog = blog /wiki = wiki /cms = config:cms.</description>
    </item>
    
    <item>
      <title>Openstack Source Code Debug</title>
      <link>https://palagend.github.io/posts/2019/09/openstack-source-code-debug/</link>
      <pubDate>Thu, 19 Sep 2019 17:37:08 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2019/09/openstack-source-code-debug/</guid>
      <description>由于openstack版本迭代的太快，很多上一个版本还能用的东西，下个版本又不能用了，我开始接触的时候是M版，等我上手之后，P版已经成熟，Q版也可以使用了。因为我需要对keystone的架构重写，所以我首先要解决的问题就是调试源代码，虽然通过各种书籍理论知道了keystone的架构模型，但实际自己去动源代码，也是很难的。
一开始我参考网上给的调试方法，结果发现，由于版本的更迭，很多东西已经不一样了，比如以前keystone自己通过脚本启动，但现在已经是依靠apache2启动了，所以，开篇之前，说明，我的所以代码都来自P版本，而且因为自己摸索时，经常遇到网上大牛给的方法不够详细，导致我无法进行，所以，我会非常详细的说明每个步骤，每个步骤我都会在P版本测试，如有疑问，欢迎交流。这里大家可以先只装keystone模块，后续需要其它模块的时候再继续装，安装就参照官网方法。我这里采用ubuntu版本的。
第一篇，我们需要对openstack采用的架构作一个简单的说明，要读懂调试源代码，首先我们要知道openstack的基本架构，而openstack每个模块都差不多，所以当我们理解一个之后，后面都可以很轻松的实现。
首先，openstack采用WSGI框架，这个大家可参考这篇文章，我觉得是我看过最清晰明了的。然后，还需要了解python paste，可以参考这篇文章。开始之前，请确保自己基本了解了这两个东西，这是继续下去的前提。其中paste后面还会涉及一些东西，到时候我会说，这里就先了解一下。
好了，当你清楚WSGI框架之后，我们来说说apache和keystone的关系，现在版本的keystone已经不需要自己启动了，都是service apache2 start即可，apache其实就是帮助keystone实现了套接字，也就是帮助keystone监听相应端口，这里对应的配置文件是/etc/apache2/sites-available/keystone.conf，同时必须在/etc/apache2/sites-enabled/中建立同名的链接才能生效。
才看keystone.conf配置文件：
Listen 5000 Listen 35357 &amp;lt;VirtualHost *:5000&amp;gt; WSGIScriptAlias / /usr/bin/keystone-wsgi-public WSGIDaemonProcess keystone-public processes=5 threads=1 user=keystone group=keystone display-name=%{GROUP} WSGIProcessGroup keystone-public WSGIApplicationGroup %{GLOBAL} WSGIPassAuthorization On LimitRequestBody 114688 &amp;lt;IfVersion &amp;gt;= 2.4&amp;gt; ErrorLogFormat &amp;quot;%{cu}t %M&amp;quot; &amp;lt;/IfVersion&amp;gt; ErrorLog /var/log/apache2/keystone.log CustomLog /var/log/apache2/keystone_access.log combined &amp;lt;Directory /usr/bin&amp;gt; &amp;lt;IfVersion &amp;gt;= 2.4&amp;gt; Require all granted &amp;lt;/IfVersion&amp;gt; &amp;lt;IfVersion &amp;lt; 2.4&amp;gt; Order allow,deny Allow from all &amp;lt;/IfVersion&amp;gt; &amp;lt;/Directory&amp;gt; &amp;lt;/VirtualHost&amp;gt; &amp;lt;VirtualHost *:35357&amp;gt; WSGIScriptAlias / /usr/bin/keystone-wsgi-admin WSGIDaemonProcess keystone-admin processes=5 threads=1 user=keystone group=keystone display-name=%{GROUP} WSGIProcessGroup keystone-admin WSGIApplicationGroup %{GLOBAL} WSGIPassAuthorization On LimitRequestBody 114688 &amp;lt;IfVersion &amp;gt;= 2.</description>
    </item>
    
    <item>
      <title>书单</title>
      <link>https://palagend.github.io/posts/2018/12/%E4%B9%A6%E5%8D%95/</link>
      <pubDate>Fri, 21 Dec 2018 10:59:47 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2018/12/%E4%B9%A6%E5%8D%95/</guid>
      <description>张小龙2018年微信公开课演讲之个人总结
Linux网络协议栈
网络基础之网络协议篇
从头搭建OpenStack
Golang正则表达式
Open vSwitch
Linux OOM
OpenStack metadata
进程釜底抽薪之后&amp;hellip;
*nix IPC
openstack虚拟机迁移
CGroup
存储基本概念
Linux错误码表</description>
    </item>
    
    <item>
      <title>Docker技术简介</title>
      <link>https://palagend.github.io/posts/2018/12/docker%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 18 Dec 2018 20:09:44 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2018/12/docker%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/</guid>
      <description>Docker技术贯穿CI/CD的整个过程，既是基础的技术，又是重要的技术。这里只是想普及一下Docker的技术， 为后续的CI/CD奠定基础，所以尽量从简单通俗的方式介绍Docker技术
什么是部署 部署就是将开发的应用程序代码和相关文件放置到服务器的指定位置，使得客户端能够通过网络来使用应用程 序提供的服务。
传统部署 开发人员在本地设置好的环境下开发并调试程序，成功之后提交编译好的程序给 运维人员；然后运维人员在生产服务器上设置好与本地开发环境一致的环境，并把程序上传到服务器启动程序 ，调式无误后，部署工作就算完成了。
容器部署 开发人员在本地开发并调试完成后，并不只是把编译好的程序提交给运维人 员，而是先将程序代码和相关文件以及程序所以依赖的环境配置一同打包到一个镜像中（Docker镜像），然后 把这个镜像提交到Docker仓库；运维人员只需要在生产服务器上拉取这个镜像到生产服务器，然后基于这个镜 像拉起一个容器，程序在容器里运行，这个容器里已经包含了程序在本地开发时一致的运行环境。
容器化部署 vs 传统部署 容器部署和传统部署最显著的不同就是对程序运行时环境（runtime environment）的处理上，前者将运行 时环境与程序本身打包在一起，随程序一起发布、部署。后者是将程序发布，但是程序的环境需要在程序所部 署的地方另外设置。 这种区别可以用”国王的皮鞋“来比喻。
Docker技术的经济效益 这里的牛皮就是运行环境, 脚是应用程序, 崎岖不平的路面是各种各样的生产服务器。 传统部署就是给所有的服务器蒙上一层“牛皮”,然后让“脚”在上面走(运行)；容器部署则是用“牛 皮”包住程序，在服务器上运行，而不需要对服务器做很多的适配工作。
传统部署方式，对开发人员来说可能比较省事，程序开发调试完毕就可以扔给运维人员了（光着脚走在牛皮大 道上当然是极好的）；容器部署对于运维人员和管理人员来说是比较省心的，只需要拿到开发人员提交过来的 容器镜像在服务器上运行起来就行了，如果容器出了问题只需要更换为新的容器就可以了。这个代价是要求开发 人员多承担了一道制作皮鞋（容器）的工序。
但是很明显从整体经济效益和管理成本上来讲，容器部署比传统部署更有优势。
Docker 上面谈了部署的概念，一直在说容器,这里就来看看容器的庐山真面目Docker。其实Docker并不是什么 新技术，而是对原有成熟技术的包装整合形成的生态系统，这个生态系统对开发部署模式产生了深远影响。
Docker技术中的一些概念  LXC Dockerfile OCI RunC Containerd Kubernetes  LXC Docker基于LXC技术，对操作系统做了一层虚拟化。 每一个容器就像一个“世外桃源”，彼此之间相互隔离（隔离性）。这些“世外桃源”虽然彼此隔 离，但是都生活在“地球”（共的操作系统内核）上，所以它们并不能无节制地使用资源（资源限制）。 Docker对容器的隔离和资源限制并不是自己实现的而是依赖于LXC提供的namespace和cgroup模块来实现的（拿来主义）。
Dockerfile OCI &amp;amp; RunC  Open Container Initiative，也就是常说的OCI，是由多家公司共同成立的项目，并由linux基金会进行管理，致力于container runtime的标准的制定和runc的开发等工作
 container有很多种，而docker是其中的一种container。
OCI -&amp;gt; RunC : Interface -&amp;gt; Implementation
下图能够解释RunC和Docker的关系： k8s为了与docker解耦合引入CRI项目： 容器化部署的意识 开发时要有容器部署意识(code,data,conf,lib,doc,log)</description>
    </item>
    
    <item>
      <title>Go语言源码分析</title>
      <link>https://palagend.github.io/posts/2018/12/go%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 18 Dec 2018 20:09:44 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2018/12/go%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>net/http client.go 结构: Client
变量: DefaultClient
接口: RoundTripper
函数: //TODO
Client指的是http客户端. 它的默认值是DefaultClient. 其中, DefaultClient以DefaultTransport作为传输层的.
典型的客户端传输层, 其内部具有缓存的TCP连接, 所以客户端应该优先重用, 而不是重新创建. 使用goroutines可以实现安全的客户端并发请求.
Client是比RoundTripper(Transport只是RounderTripper的一个实现)更高一级的存在, 用来处理重定向、cookie等HTTP细节.
 • when forwarding sensitive headers like &amp;ldquo;Authorization&amp;rdquo;, &amp;ldquo;WWW-Authenticate&amp;rdquo;, and &amp;ldquo;Cookie&amp;rdquo; to untrusted targets. These headers will be ignored when following a redirect to a domain that is not a subdomain match or exact match of the initial domain. For example, a redirect from &amp;ldquo;foo.com&amp;rdquo; to either &amp;ldquo;foo.com&amp;rdquo; or &amp;ldquo;sub.</description>
    </item>
    
    <item>
      <title>技术白话即《数据结构与算法》读书心得与笔记</title>
      <link>https://palagend.github.io/posts/2018/12/%E6%8A%80%E6%9C%AF%E7%99%BD%E8%AF%9D%E5%8D%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E5%BF%83%E5%BE%97%E4%B8%8E%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 18 Dec 2018 20:09:44 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2018/12/%E6%8A%80%E6%9C%AF%E7%99%BD%E8%AF%9D%E5%8D%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E5%BF%83%E5%BE%97%E4%B8%8E%E7%AC%94%E8%AE%B0/</guid>
      <description>技和术的区别 解决&amp;rdquo;好&amp;rdquo;问题的能力在于&amp;rdquo;技&amp;rdquo;&amp;ldquo;,解决&amp;rdquo;新&amp;rdquo;问题的能力在于&amp;rdquo;术&amp;rdquo;.解决问题的实力在于&amp;rdquo;技术兼备&amp;rdquo;.
我们通常所说的掌握xx框架,熟练xx编程语言,xx工具快捷键娴熟,能够快速定位xx问题&amp;hellip;,这些体现的都是“技”的水平,&amp;ldquo;技&amp;rdquo;的水平高,那么在解决已知问题方面会更快,更好,但是面对“新的问题”,“技”的优势就没有那么明显了. 这时候,“术”的优势就显现出来了.
所谓的“术”,在IT领域,表现为对实际计算问题的抽象能力.实际中的计算需求无穷无尽,有的计算需求已经有对应的程序可解决,“拿来主义”就能搞定.但是有的“新”问题,没有现成的程序可用,就需要运用“术”的能力. 针对新问题,采用成熟的算法和数据结构或者设计新的算法和数据结构,编写程序来解决问题.这也是创新能力集中体现的地方.
总之“技术兼备”才能有信心应对形形色色的计算需求.
计算机问题的求解 计算机问题求解,就是利用计算机去解决实际问题.数据结构结构和算法,就是利用计算机去解决实际问题过程中采用的方法. &amp;gt; 人们开发(设计+编码)一个程序,通常是为了解决一个问题,该程序的每次执行能处理该问题的一个实例.</description>
    </item>
    
    <item>
      <title>桃花依旧笑春风</title>
      <link>https://palagend.github.io/posts/2018/12/%E6%A1%83%E8%8A%B1%E4%BE%9D%E6%97%A7%E7%AC%91%E6%98%A5%E9%A3%8E/</link>
      <pubDate>Thu, 06 Dec 2018 20:13:41 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2018/12/%E6%A1%83%E8%8A%B1%E4%BE%9D%E6%97%A7%E7%AC%91%E6%98%A5%E9%A3%8E/</guid>
      <description>  放下微信 培养兴趣 专注事情 建立自尊  </description>
    </item>
    
    <item>
      <title>Creating a New Theme</title>
      <link>https://palagend.github.io/posts/2014/09/creating-a-new-theme/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://palagend.github.io/posts/2014/09/creating-a-new-theme/</guid>
      <description>Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description>
    </item>
    
    <item>
      <title>(Hu)go Template Primer</title>
      <link>https://palagend.github.io/posts/2014/07/hugo-template-primer/</link>
      <pubDate>Mon, 28 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>https://palagend.github.io/posts/2014/07/hugo-template-primer/</guid>
      <description>Hugo uses the excellent go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in go templates.
This document is a brief primer on using go templates.</description>
    </item>
    
  </channel>
</rss>