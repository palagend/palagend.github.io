<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>困惑的人生</title>
    <link>https://palagend.github.io/</link>
    <description>Recent content on 困惑的人生</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Wed, 06 Nov 2019 19:25:28 +0800</lastBuildDate>
    
	<atom:link href="https://palagend.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>李健与孟小蓓的爱情就像信天翁</title>
      <link>https://palagend.github.io/posts/2019/11/%E6%9D%8E%E5%81%A5%E4%B8%8E%E5%AD%9F%E5%B0%8F%E8%93%93%E7%9A%84%E7%88%B1%E6%83%85%E5%B0%B1%E5%83%8F%E4%BF%A1%E5%A4%A9%E7%BF%81/</link>
      <pubDate>Wed, 06 Nov 2019 19:25:28 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2019/11/%E6%9D%8E%E5%81%A5%E4%B8%8E%E5%AD%9F%E5%B0%8F%E8%93%93%E7%9A%84%E7%88%B1%E6%83%85%E5%B0%B1%E5%83%8F%E4%BF%A1%E5%A4%A9%E7%BF%81/</guid>
      <description>如果说歌手中一定有一个另类，那一定是李健。
世人皆匆忙，总有几个人不想赶路。
就如同高晓松说的一般：“我们身边的这一波人都不是当初的模样了，只有李健还是当年那个李健。”
然而最重要的是他对妻子的痴情与专一，打动了无数人。
参加《我是歌手》后，
李健成了无数人心中的偶像，尤其是众多女性眼里的“万人迷”。
有个记者曾经问他：“你知道么，很多女人都爱你。”
而当时李健是这么回答的：
 “我对女人充满了关爱和尊敬，
但我不会跟女性走得太近，
也不可能离婚。
我也喜欢很多女孩子，
但远远欣赏就够了。
我们可以欣赏很多人，
但不一定要去占有她。”
 李健出道这么多年，也一直保持着零绯闻的记录。
活成众人男神的他，从始至终，只钟情于一人，就是那个她10岁时遇见的姑娘——孟小蓓。
曾经有记者问李健，你们在哪里度的蜜月？
李健回答：“我一生都在度蜜月”。
我们羡慕“从前慢，车、马、邮件都慢，一生只爱一个人”的时光时，李健是那个真正溯流而上，去实现它的人。
李健在自己10岁时就与自己的妻子孟小蓓认识了。
“郎骑竹马来，绕床弄青梅”，后来那首被王菲一唱而红的《传奇》，就是李健写来形容他跟妻子奇妙的际遇。
&amp;ldquo;只因为在人群中多看了你一眼，再也没能忘掉你容颜&amp;rdquo;
那一年他十岁，她五岁。
无论贫贵富贱，小贝壳都默默的陪在李建身边不离不弃。
不管是广电总局上班的三年，还是后来在“水木年华”大红大紫的几年，亦或是李健隐退在四合院清贫写歌的那几年。
两人从来没有出现过裂痕，平淡却很知足。
小贝壳也成为了李健的精神之柱。
或许所谓的灵魂伴侣就是这般模样吧。
之后，李健为她写了很多情歌，《小鸟睡在我身旁》、《一往情深的恋人》、《转眼瞬间》以及《恋人》。
几乎每张专辑都有一首曲子与小贝壳有关。
《恋人》：
“写这首歌的时候，已经是后半夜了，用尽所有的情感专注于它，我的小贝壳被感动的一塌糊涂，可不知为什么脑海里总浮现天鹅的形象。后来才听说，一对天鹅中如果有一只死去，另一只也会随之而去。”
《小鸟睡在我身旁》：
“有一天夜里，我看着窗外树上的鸟窝，想里面的小鸟一定睡得很香甜，我身旁的小贝壳也静静地睡着，就像一只小鸟&amp;hellip; &amp;hellip; ”
《在每个想你的夜里》：
“写这首歌是在芝加哥，每每听到都会想起那里的冬天，至少能感觉当时空气中的味道。”
《转眼瞬间》：
“我不太在意变老，因为见过活得精彩的老人，可我在乎眼中的你，看到你变老，我会伤感&amp;hellip;”
《凌晨两点》：
“这是脆弱的时刻，看着窗外的大雾，弹起吉他：我的生活不能没有你……”
他一生的情歌，都只为她而唱。
网上曾有个很流行的问题：“怎样才能嫁给李健？”
有一个很火的答案这样说：
 你要会泡茶，养花，煮咖啡，懂摄影，要会弹琴画画还要厨艺好，要会翻译叶芝的诗，会做牛排番茄面、地中海沙拉。要知道玻璃蜥蜴不是蛇，要知道怎么做出清香晶莹最好吃的白米粽，还要成为清华的博士，在路上被星探搭讪。最重要的是，你还要在5岁的时候遇见他。”
 这段看似“你在逗我吗？”的段子般的条件，却真实的体现在了两人的婚姻关系中。其实就是李
他们真正做到了把婚姻活成了诗情画意。
李健会用“小贝壳”来称呼妻子，妻子会用各种“先生”来指代他，所有的“柴米油盐酱醋茶”都雅成了“ 琴棋书画诗酒茶”。
李健说， “她是天上掉下来的”。
“太太最终吸引我的不是容貌，是她说话的方式和内容。”
翻看小贝壳的微博，会发现，两个人这么多年，如诗一般的始终甜蜜如初。</description>
    </item>
    
    <item>
      <title>PasteDeploy</title>
      <link>https://palagend.github.io/posts/2019/10/pastedeploy/</link>
      <pubDate>Thu, 03 Oct 2019 16:13:20 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2019/10/pastedeploy/</guid>
      <description>PasteDeploy 简介 PasteDeploy 是用来发现和配置 WSGI 应用的一个框架，可以方便地从配置文件加载 WSGI 应用。
PasteDeploy 的安装命令是 pip install PasteDeploy
PasteDeploy 配置文件 使用 PasteDeploy 都是围绕配置文件展开的，所以了解 PasteDeploy 配置的格式是熟练使用 PasteDeploy 的前提。
PasteDeploy 的配置文件由若干 section 组成，section 的组成格式如下：
[type:name]  其中方括号括起来的部分是声明 setion 的起始部分，section 的类型（type）和 section 的名称（name），如：[app:main] 等。section 的 type 可以有：app、composite、filter、pipeline、filter-app 等。
每个 section 中具体配置项的格式就是基本的 ini 格式：key = value，此外，PasteDeploy 的配置文件中使用 “#” 标注注释。
在基本了解 PasteDeploy 配置文件的书写格式后，我们不妨看一个实例，来具体了解不同 type 的 section。
PasteDeploy 中 section 的 type 示例 1：PasteDeploy 配置文件
[composite:main] use = egg:Paste#urlmap / = home /blog = blog /wiki = wiki /cms = config:cms.</description>
    </item>
    
    <item>
      <title>Openstack Source Code Debug</title>
      <link>https://palagend.github.io/posts/2019/09/openstack-source-code-debug/</link>
      <pubDate>Thu, 19 Sep 2019 17:37:08 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2019/09/openstack-source-code-debug/</guid>
      <description>由于openstack版本迭代的太快，很多上一个版本还能用的东西，下个版本又不能用了，我开始接触的时候是M版，等我上手之后，P版已经成熟，Q版也可以使用了。因为我需要对keystone的架构重写，所以我首先要解决的问题就是调试源代码，虽然通过各种书籍理论知道了keystone的架构模型，但实际自己去动源代码，也是很难的。
一开始我参考网上给的调试方法，结果发现，由于版本的更迭，很多东西已经不一样了，比如以前keystone自己通过脚本启动，但现在已经是依靠apache2启动了，所以，开篇之前，说明，我的所以代码都来自P版本，而且因为自己摸索时，经常遇到网上大牛给的方法不够详细，导致我无法进行，所以，我会非常详细的说明每个步骤，每个步骤我都会在P版本测试，如有疑问，欢迎交流。这里大家可以先只装keystone模块，后续需要其它模块的时候再继续装，安装就参照官网方法。我这里采用ubuntu版本的。
第一篇，我们需要对openstack采用的架构作一个简单的说明，要读懂调试源代码，首先我们要知道openstack的基本架构，而openstack每个模块都差不多，所以当我们理解一个之后，后面都可以很轻松的实现。
首先，openstack采用WSGI框架，这个大家可参考这篇文章，我觉得是我看过最清晰明了的。然后，还需要了解python paste，可以参考这篇文章。开始之前，请确保自己基本了解了这两个东西，这是继续下去的前提。其中paste后面还会涉及一些东西，到时候我会说，这里就先了解一下。
好了，当你清楚WSGI框架之后，我们来说说apache和keystone的关系，现在版本的keystone已经不需要自己启动了，都是service apache2 start即可，apache其实就是帮助keystone实现了套接字，也就是帮助keystone监听相应端口，这里对应的配置文件是/etc/apache2/sites-available/keystone.conf，同时必须在/etc/apache2/sites-enabled/中建立同名的链接才能生效。
才看keystone.conf配置文件：
Listen 5000 Listen 35357 &amp;lt;VirtualHost *:5000&amp;gt; WSGIScriptAlias / /usr/bin/keystone-wsgi-public WSGIDaemonProcess keystone-public processes=5 threads=1 user=keystone group=keystone display-name=%{GROUP} WSGIProcessGroup keystone-public WSGIApplicationGroup %{GLOBAL} WSGIPassAuthorization On LimitRequestBody 114688 &amp;lt;IfVersion &amp;gt;= 2.4&amp;gt; ErrorLogFormat &amp;quot;%{cu}t %M&amp;quot; &amp;lt;/IfVersion&amp;gt; ErrorLog /var/log/apache2/keystone.log CustomLog /var/log/apache2/keystone_access.log combined &amp;lt;Directory /usr/bin&amp;gt; &amp;lt;IfVersion &amp;gt;= 2.4&amp;gt; Require all granted &amp;lt;/IfVersion&amp;gt; &amp;lt;IfVersion &amp;lt; 2.4&amp;gt; Order allow,deny Allow from all &amp;lt;/IfVersion&amp;gt; &amp;lt;/Directory&amp;gt; &amp;lt;/VirtualHost&amp;gt; &amp;lt;VirtualHost *:35357&amp;gt; WSGIScriptAlias / /usr/bin/keystone-wsgi-admin WSGIDaemonProcess keystone-admin processes=5 threads=1 user=keystone group=keystone display-name=%{GROUP} WSGIProcessGroup keystone-admin WSGIApplicationGroup %{GLOBAL} WSGIPassAuthorization On LimitRequestBody 114688 &amp;lt;IfVersion &amp;gt;= 2.</description>
    </item>
    
    <item>
      <title>Linux /sys目录下各个子目录说明</title>
      <link>https://palagend.github.io/posts/2019/09/linux-/sys%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%90%84%E4%B8%AA%E5%AD%90%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Thu, 19 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://palagend.github.io/posts/2019/09/linux-/sys%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%90%84%E4%B8%AA%E5%AD%90%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E/</guid>
      <description>/sys/devices  该目录下是全局设备结构体系，包含所有被发现的注册在各种总线上的各种物理设备。一般来说，所有的物理设备都按其在总线上的拓扑结构来显示，但有两个例外，即platform devices和system devices。platform devices一般是挂在芯片内部的高速或者低速总线上的各种控制器和外设，它们能被CPU直接寻址；system devices不是外设，而是芯片内部的核心结构，比如CPU，timer等，它们一般没有相关的驱动，但是会有一些体系结构相关的代码来配置它们。
(sys/devices是内核对系统中所有设备的分层次表达模型，也是/sys文件系统管理设备的最重要的目录结构)
 /sys/dev  该目录下维护一个按照字符设备和块设备的主次号码(major:minor)链接到真是设备(/sys/devices)的符号链接文件。
 /sys/class  该目录下包含所有注册在kernel里面的设备类型，这是按照设备功能分类的设备模型，每个设备类型表达具有一种功能的设备。每个设备类型子目录下都是这种设备类型的各种具体设备的符号链接，这些链接指向/sys/devices/name下的具体设备。设备类型和设备并没有一一对应的关系，一个物理设备可能具备多种设备类型；一个设备类型只表达具有一种功能的设备，比如：系统所有输入设备都会出现在/sys/class/input之下，而不论它们是以何种总线连接到系统的。(/sys/class也是构成linux统一设备模型的一部分)
 /sys/block  该目录下的所有子目录代表着系统中当前被发现的所有块设备。按照功能来说放置在/sys/class下会更合适，但由于历史遗留因素而一直存在于/sys/block，但从linux 2.6.22内核开始这部分就已经标记为过去时，只有打开了CONFIG_SYSFS_DEPRECATED配置编译才会有这个目录存在，并且其中的内容在从linux2.6.26版本开始已经正式移到了/sys/class/block，旧的接口/sys/block为了向后兼容而保留存在，但其中的内容已经变为了指向它们在/sys/devices/中真实设备的符号链接文件。
 /sys/bus  该目录下的每个子目录都是kernel支持并且已经注册了的总线类型。这是内核设备按照总线类型分层放置的目录结构，/sys/devices中的所有设备都是连接于某种总线之下的，bus子目录下的每种具体总线之下可以找到每个具体设备的符号链接，一般来说每个子目录(总线类型)下包含两个子目录，一个是devices，另一个是drivers；其中devices下是这个总线类型下的所有设备，这些设备都是符号链接，它们分别指向真正的设备(/sys/devices/name/下)；而drivers下是所有注册在这个总线上的驱动，每个driver子目录下 是一些可以观察和修改的driver参数。 (它也是构成linux统一设备模型的一部分)
 /sys/fs  按照设计，该目录用来描述系统中所有的文件系统，包括文件系统本身和按照文件系统分类存放的已挂载点。
 /sys/kernel  这个目录下存放的是内核中所有可调整的参数
 /sys/firmware  这里是系统加载固件机制的对用户空间的接口，关于固件有专用于固件加载的一套API，在附录 LDD3 一书中有关于内核支持固件加载机制的更详细的介绍；
 /sys/module  该目录下有系统中所有的模块信息，不论这些模块是以内联(inlined)方式编译到内核映像文件中还是编译为外模块(.ko文件)，都可能出现在/sys/module中。即module目录下包含了所有的被载入kernel的模块。
 /sys/power  该目录是系统中的电源选项，对正在使用的power子系统的描述。这个目录下有几个属性文件可以用于控制整个机器的电源状态，如可以向其中写入控制命令让机器关机/重启等等。</description>
    </item>
    
    <item>
      <title>谈谈产品思维和项目思维</title>
      <link>https://palagend.github.io/posts/2019/07/%E8%B0%88%E8%B0%88%E4%BA%A7%E5%93%81%E6%80%9D%E7%BB%B4%E5%92%8C%E9%A1%B9%E7%9B%AE%E6%80%9D%E7%BB%B4/</link>
      <pubDate>Fri, 12 Jul 2019 08:23:19 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2019/07/%E8%B0%88%E8%B0%88%E4%BA%A7%E5%93%81%E6%80%9D%E7%BB%B4%E5%92%8C%E9%A1%B9%E7%9B%AE%E6%80%9D%E7%BB%B4/</guid>
      <description>产品思维和项目思维本质上是实现客户需求的两种工作/服务模式。传统领域就有这两种服 务模式。餐饮业中肯德基的服务模式采用的就是产品思维， 客户只能在已有的套餐中选择，而不能随意定制。但是像管家式服装定制的服务模式采用 的就是 项目思维，客户能够根据自己的心意随意定制，这种服务成本自然不低。我们通常看到的 现代服务业中，服务模式大多采用的是产品思维，因为这种方式能够降低成本， 提高效率。
软件工程领域也是同样的道理，以产品思维进行开发/交付，就像是雕琢自己的艺术品， 主人翁意识较强；而以项目思维进行开发/交付，更容易诱发应付交差的情绪，无休止的 打不完的豆豆，容易消磨人的意志。
以产品思维开发的项目，向客户交付的是标准的产品，我们在解决客户的问题反馈和诉求 时以产品线为单位进行，这样的话，尽管客户种类很多，但我们的关注点只在产品线 ，公司内部常态工作流不会被打断；以项目思维开发的项目，向客户交付的是由客户自己 定义</description>
    </item>
    
    <item>
      <title>Openstack Instance Ha Propersal</title>
      <link>https://palagend.github.io/posts/2019/07/openstack-instance-ha-propersal/</link>
      <pubDate>Thu, 11 Jul 2019 17:12:47 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2019/07/openstack-instance-ha-propersal/</guid>
      <description>This post is a copy from russellbryant
 In a perfect world, every workload that runs on OpenStack would be a cloud native application that is horizontally scalable and fault tolerant to anything that may cause a VM to go down. However, the reality is quite different. We continue to see a high demand for support of traditional workloads running on top of OpenStack and the HA expectations that come with them.</description>
    </item>
    
    <item>
      <title>Libvirt Xml</title>
      <link>https://palagend.github.io/posts/2019/06/libvirt-xml/</link>
      <pubDate>Sat, 29 Jun 2019 18:10:08 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2019/06/libvirt-xml/</guid>
      <description>#虚拟化类型为kvm(type=&#39;kvm&#39;)，可选的还有qemu &amp;lt;domain type=&#39;kvm&#39; xmlns:qemu=&#39;http://libvirt.org/schemas/domain/qemu/1.0&#39;&amp;gt; #虚拟机名字 openstack1-1 &amp;lt;name&amp;gt;openstack1-1&amp;lt;/name&amp;gt; #虚拟机预分配内存8388608K,这个是宿主机允许虚拟机使用的最大内存，并不是在虚拟机里用free看到的内存 &amp;lt;memory unit=&#39;KiB&#39;&amp;gt;8388608&amp;lt;/memory&amp;gt; #虚拟机当前定义内存(8388608)，free看到的内存，可以使用virsh setmem调整内存 &amp;lt;currentMemory unit=&#39;KiB&#39;&amp;gt;8388608&amp;lt;/currentMemory&amp;gt; #虚拟机cpu个数 &amp;lt;vcpu placement=&#39;static&#39;&amp;gt;4&amp;lt;/vcpu&amp;gt; &amp;lt;os&amp;gt; #模拟的系统架构x86_64,模拟机器类型rhel6.5 &amp;lt;type arch=&#39;x86_64&#39; machine=&#39;rhel6.5.0&#39;&amp;gt;hvm&amp;lt;/type&amp;gt; #虚拟机开机引导项，hd：硬盘，cdrom：光盘，即先硬盘，后光盘 &amp;lt;boot dev=&#39;hd&#39;/&amp;gt; &amp;lt;boot dev=&#39;cdrom&#39;/&amp;gt; &amp;lt;bootmenu enable=&#39;yes&#39;/&amp;gt; &amp;lt;bios useserial=&#39;yes&#39; rebootTimeout=&#39;0&#39;/&amp;gt; &amp;lt;/os&amp;gt; &amp;lt;features&amp;gt; &amp;lt;acpi/&amp;gt; &amp;lt;apic/&amp;gt; &amp;lt;pae/&amp;gt; &amp;lt;/features&amp;gt; #虚拟机cpu模拟类型，host-model，使用宿主机cpu的所有可使用特性 &amp;lt;cpu mode=&#39;host-model&#39;&amp;gt; &amp;lt;model fallback=&#39;allow&#39;/&amp;gt; &amp;lt;/cpu&amp;gt; &amp;lt;clock offset=&#39;utc&#39;/&amp;gt; &amp;lt;on_poweroff&amp;gt;destroy&amp;lt;/on_poweroff&amp;gt; &amp;lt;on_reboot&amp;gt;restart&amp;lt;/on_reboot&amp;gt; &amp;lt;on_crash&amp;gt;restart&amp;lt;/on_crash&amp;gt; &amp;lt;devices&amp;gt; #运行虚拟机的程序，qemu-kvm，可以在宿主机使用ps -ef | grep qemu-kvm 看到 &amp;lt;emulator&amp;gt;/usr/libexec/qemu-kvm&amp;lt;/emulator&amp;gt; #定义虚拟机磁盘 &amp;lt;disk type=&#39;file&#39; device=&#39;disk&#39;&amp;gt; #虚拟机磁盘为qcow2格式，如果你创建或使用的磁盘是raw格式，需要修改为raw &amp;lt;driver name=&#39;qemu&#39; type=&#39;qcow2&#39; cache=&#39;none&#39;/&amp;gt; #磁盘路径 &amp;lt;source file=&#39;/data/vhosts/jython/openstack/openstack1-1.disk&#39;/&amp;gt; #第一块为vda，第二块就为vdb，不能重复，重复虚拟机启动报错 &amp;lt;target dev=&#39;vda&#39; bus=&#39;virtio&#39;/&amp;gt; &amp;lt;/disk&amp;gt; &amp;lt;controller type=&#39;ide&#39; index=&#39;0&#39;&amp;gt; &amp;lt;/controller&amp;gt; &amp;lt;controller type=&#39;virtio-serial&#39; index=&#39;0&#39;&amp;gt; &amp;lt;/controller&amp;gt; &amp;lt;controller type=&#39;usb&#39; index=&#39;0&#39;&amp;gt; &amp;lt;/controller&amp;gt; #虚拟机网络为桥接模式bridge，桥接网桥为br-ex，要确保网桥br-ex存在，并且能使用 &amp;lt;interface type=&#39;bridge&#39;&amp;gt; &amp;lt;source bridge=&#39;br-ex&#39;/&amp;gt; &amp;lt;model type=&#39;virtio&#39;/&amp;gt; &amp;lt;/interface&amp;gt; #第二张网卡，如果需要多块网卡，就复制多次 &amp;lt;interface type=&#39;bridge&#39;&amp;gt; &amp;lt;source bridge=&#39;br-ex&#39;/&amp;gt; &amp;lt;model type=&#39;virtio&#39;/&amp;gt; &amp;lt;/interface&amp;gt; &amp;lt;console type=&#39;pty&#39;&amp;gt; &amp;lt;/console&amp;gt; &amp;lt;input type=&#39;mouse&#39; bus=&#39;ps2&#39;/&amp;gt; #使用vnc协议，autoport=&#39;yes&#39;:自动分配端口，从5900开始 &amp;lt;graphics type=&#39;vnc&#39; autoport=&#39;yes&#39; listen=&#39;0.</description>
    </item>
    
    <item>
      <title>Ceph Arch</title>
      <link>https://palagend.github.io/posts/2019/06/ceph-arch/</link>
      <pubDate>Fri, 28 Jun 2019 11:24:03 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2019/06/ceph-arch/</guid>
      <description>Ceph生态系统架构可以划分为四部分：
*client*：客户端（数据用户）。client向外export出一个POSIX文件系统接口，供应用程序调用，并连接mon/mds/osd，进行元数据及数据交互；最原始的client使用FUSE来实现的，现在写到内核里面了，需要编译一个ceph.ko内核模块才能使用。
*mon*：集群监视器，其对应的daemon程序为cmon（Ceph Monitor）。mon监视和管理整个集群，对客户端export出一个网络文件系统，客户端可以通过mount -t ceph monitor_ip:/ mount_point命令来挂载Ceph文件系统。根据官方的说法，3个mon可以保证集群的可靠性。
*mds*：元数据服务器，其对应的daemon程序为cmds（Ceph Metadata Server）。Ceph里可以有多个MDS组成分布式元数据服务器集群，就会涉及到Ceph中动态目录分割来进行负载均衡。
*osd*：对象存储集群，其对应的daemon程序为cosd（Ceph Object StorageDevice）。osd将本地文件系统封装一层，对外提供对象存储的接口，将数据和元数据作为对象存储。这里本地的文件系统可以是ext2/3，但Ceph认为这些文件系统并不能适应osd特殊的访问模式，它们之前自己实现了ebofs，而现在Ceph转用btrfs。</description>
    </item>
    
    <item>
      <title>书单</title>
      <link>https://palagend.github.io/posts/2018/12/%E4%B9%A6%E5%8D%95/</link>
      <pubDate>Fri, 21 Dec 2018 10:59:47 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2018/12/%E4%B9%A6%E5%8D%95/</guid>
      <description>张小龙2018年微信公开课演讲之个人总结
Linux网络协议栈
网络基础之网络协议篇
从头搭建OpenStack
Golang正则表达式
Open vSwitch
Linux OOM
OpenStack metadata
进程釜底抽薪之后&amp;hellip;
*nix IPC
openstack虚拟机迁移
CGroup
存储基本概念
Linux错误码表</description>
    </item>
    
    <item>
      <title>在Windows10上利用minikube&#43;hyperv安装单节点k8s集群</title>
      <link>https://palagend.github.io/posts/2018/12/%E5%9C%A8windows10%E4%B8%8A%E5%88%A9%E7%94%A8minikube-hyperv%E5%AE%89%E8%A3%85%E5%8D%95%E8%8A%82%E7%82%B9k8s%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Thu, 20 Dec 2018 00:55:02 +0800</pubDate>
      
      <guid>https://palagend.github.io/posts/2018/12/%E5%9C%A8windows10%E4%B8%8A%E5%88%A9%E7%94%A8minikube-hyperv%E5%AE%89%E8%A3%85%E5%8D%95%E8%8A%82%E7%82%B9k8s%E9%9B%86%E7%BE%A4/</guid>
      <description>准备好二进制文件 注意本教程使用的版本如下:
* minikube v0.31.0
* kubeadm v1.13.1
* kubelet v1.13.1
* kubectl v1.13.1
下载minikube, 下载命令:
curl -C - -L# -o $HOME/.local/bin/minikube https://github.com/kubernetes/minikube/releases/download/v0.31.0/minikube-windows-amd64  或者从这里下载源码编译
借助VPN下载二进制文件: kubeadm, kubelet, kubectl, 下载命令:
#VERSION=$(curl https://storage.googleapis.com/kubernetes-release/release/stable.txt) mkdir -p $HOME/.minikube/cache/v1.13.1 &amp;amp;&amp;amp; \ cd $HOME/.minikube/cache/v1.13.1 &amp;amp;&amp;amp; \ curl -C - -L#O https://storage.googleapis.com/kubernetes-release/release/v1.13.1/bin/windows/amd64/{kubelet,kubeadm,kubectl}  下载kubernetes所需的docker镜像, 脚本内容如下:
cat download-kubernetes.sh
#!/bin/bash #本脚本将拉取以下9个images #kube-proxy-amd64:v1.13.1 #kube-controller-manager-amd64:v1.13.1 #kube-scheduler-amd64:v1.13.1 #kube-apiserver-amd64:v1.13.1 #pause-amd64:3.1 #coredns:1.2.6 #etcd-amd64:3.2.24 #kubernetes-dashboard-amd64:v1.10.0 #flannel:v0.10.0-amd64 set -e #运行kubeadm config images list确认指定版本 K8S_VERSION=v1.13.1 ETCD_VERSION=3.</description>
    </item>
    
  </channel>
</rss>